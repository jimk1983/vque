#!/bin/bash
make_file="Makefile"
BUILDS=debug

#目录
INSTALL_BIN="/usr/local/bin"
INSTALL_LIB="/usr/local/lib"
INSTALL_INC="/usr/local/include"
#项目目录定inc="-I."
ROOT_DEP="${ROOTDIR}/deps"
ROOT_BIN="${ROOTDIR}/outs"
make_depsinc+="-I${ROOTDIR}/deps/include"
make_depslink="-L${ROOTDIR}/deps/lib"
make_depslink+="-L${ROOTDIR}/libs/linux"

#make编译配置选项
CC=gcc
COPTM=-Wall
MAKE=make
AR=ar
COPTM+=-Werror
AR+=cr

#CFLAGS += -g -O0 #单步调试-O0, 否则-O3
#CFLAGS += -std=c++11


#项目依赖依次顺序放在前面
#每个目录是单独的形式存在，具备单独的Makefile来控制
#=================================================
#项目名称
declare -a projectalls
projectalls=(
	vos
	vque
	proxygw
	example
)
#
#输出项目配置项
# type    	[so|app|ar] so输出态库,app输出可执行程序, ar 静态库
# rootpath  [folder]  顶层目录
# makepath  [folder1 folde2 ..]  基于顶层目录下的多个待编译的子目录
# links     [-lpthread ..]  编译链接库选项
# cflags    [-I. ..]  gcc编译option flag选项
# builds    [yes|no]  是否生成目标输出

declare -A vos
vos=(	[types]=ar
	[builds]=yes
	[rootpath]="libs"
	[makepath]="libvos"
	[links]="${make_depslink} -ldl -lpthread -lrt -lm"
	[cflags]="${make_depsinc}")

declare -A vque
vque=(	[types]=ar
	[builds]=yes
	[rootpath]="libs"
	[makepath]="libvque"
        [links]="${make_depslink} -lvos -ldl -lpthread -lrt -lm"
        [cflags]="${make_depsinc}")

declare -A proxygw
proxygw=(
	[types]=app
	[builds]=yes
	[rootpath]="src"
	[makepath]="main,share"
        [links]="${make_depslink} -lvque -lvos -ldl -lpthread -lrt -lm"
        [cflags]="${make_depsinc}")

declare -A example
example=(
	[types]=app
	[builds]=no
	[rootpath]="example"
	[makepath]="client"
        [links]="${make_depslink} -lvque -lvos -ldl -lpthread -lrt -lm"
        [cflags]="${make_depsinc}")

#=================================================

function createmakefiles() {
#MakeFile编译文件生成
cat << !MAKE_ALL! > $1
ifeq (\$(BUILDS), debug)
	CFLAG+=-g -O0
	BUILDS=debug
else ifeq (\$(BUILDS), release)
	CFLAG+=-O3
	BUILDS=release
else
	CFLAG+=-O3
	BUILDS=release
endif

# dependent include
DEP_INC=${make_depsinc}
DEP_INC=${make_depsinc}
# installation directory
INST_BIN=${INSTALL_BIN}
INST_LIB=${INSTALL_LIB}
INST_INC=${INSTALL_INC}

# version control
VERSION=${mversion}
VER_MAJOR=${mver_major}
VER_MINOR=${mver_minor}
VER_REVISION=${mver_revision}

# all : prepare targets...
!MAKE_ALL!
}

#Start to create new Makefile

# 预先创建子目录
make_subdir=""
# .c => .o 规则集合记录
make_obj_file="objs.mk"
# 目标预制文件记录
make_target_file="target.mk"
# 安装临时文件记录
make_install_file="install.mk"
# 卸载临时文件记录
make_uninstall_file="uninstall.mk"
# obj 对象集合，避免重复编译记录
make_obj_names=""

declare -A make_deps
declare -A srcfiles

pdbg "config --builds=$BUILDS"

function getsrcfiles(){
	i=0
    for element in `ls $1`
    do
        dir_or_file=$1"/"$element
        if [ -d $dir_or_file ]
		then
            getsrcfiles $dir_or_file
        else
            filename=$(find $dir_or_file -type f -a \( -name \*.c -o -name \*.C -o \
                             -name \*.cc -o -name \*.cpp -o -name \*.CPP \
                             -o -name \*.c++ -o -name \*.cp -o -name \*.cxx \));
			srcfiles[$i]=$filename
			i+=1
        fi
    done
}


pinf "========================================================================"
for item in ${projectalls[@]}; 
do
	pdbg "========================================================================"
	target_so_name=""
    	target_so_major=""
    	target_so=""
    	target_ar=""
    	target_app=""
    	target_objs=""
    	target_ars=""
	
	types=$(eval echo \${${item}[types]})
	build=$(eval echo \${${item}[builds]})
	make_cflag=$(eval echo \${$item[cflags]})

	if [ "$build" != "yes" ] && [ "$build" != "on" ]; then
                #pwar "bulid(${build}), we will not build this target=${item}!"
                #pinf "if you want build, set [build]=yes"
                continue
        fi

	pdbg "project: ${item}"	

	if [ "$types" = "so" ]; then
		target_so_base="lib${item}.so"
        	target_so_name="\$(BIN_DIR)/${target_so_base}"
        	target_so_major="${target_so_name}.\$(VER_MAJOR)"
        	target_so="${target_so_name}.\$(VERSION)"
		
		make_deps[-l${item}]="$target_so"

		pdbg "output [so]: ${target_so}"
	elif [ "$types" = "ar" ]; then
		target_ar_base="lib${item}.a"
        	target_ar="\$(BIN_DIR)/${target_ar_base}"
		
		make_deps[-l${item}]="$target_ar"

		pdbg "output [ar]: ${target_ar}"
	elif [ "$types" = "app" ]; then
		target_app_base="${item}"
                target_app="\$(BIN_DIR)/${target_app_base}"
                
		pdbg "output [app]: ${target_app}"
	else
        	perr "UNKNOWN type(${types}) error!"
        	pinf "type mast be: so|ar|so+ar|app"
        	exit 1
	fi
	
	#开始给每个工程单独新建Makefile
	makefiles=$make_file
	makefiles+=${item}
	createmakefiles ${makefiles}
	rootpath=$(eval echo \${${item}[rootpath]})
	makepath=$(eval echo \${${item}[makepath]})
	rootfull="$ROOTDIR/${rootpath}"	
	makearry=(${makepath//,/ })
	declare -A rootdirs
	
	#每个工程单独编译和生成
	echo "BIN_DIR=\${ROOT_BIN}/\$(BUILDS)" >> $makefiles
	echo "OBJ_DIR=${ROOT_BIN}/${item}/\$(BUILDS)_obj" >> $makefiles
	#注意工程的根目录只能有唯一的一个，不能有多个
	echo "SRC_DIR=${rootfull}"
	echo "SRC_DIR=${rootfull}"
	printf "all : prepare" >> $makefiles
	
	#收集当前项目指定的源文件, root下的递归子目录的所有文件
	i=0
	for itempath in ${makearry[@]};
	do
		#re-save the real path
		rootdirs[$i]=${rootfull}/${itempath}		
		i+=1
	done

	#收集当前项目指定的源码目录下的源文件,全部收集在srcfiles
	for itempath in ${rootdirs[@]};
        do
		getsrcfiles $itempath
    done
	
	# 收集当前项目指定的源文件，转换为目标*.o组装处理
	for path_name in ${srcfiles[@]}; do
		obj_name="\$(SRC_DIR)/${path_name%.*}.o"
		obj_path="${path_name%/*}"
		
		[[ "$make_subdir" =~ "$obj_path" ]] || {
			# append new sub ddir
			make_subdir+=" $obj_path"
		}
		
        # obj的头文件依赖
        dependent_file=""
        for dep_header in $(grep "#include " $path_name); do
            [ "#include" = "${dep_header}" ] && continue
            # remove < , > or "
            dep_header=${dep_header#*<}
            dep_header=${dep_header%>*}
            dep_header=${dep_header#*\"}
            dep_header=${dep_header%\"*}
            
			pdbg "$dep_header"
            for dep_match in ${header_files}; do
                [[ "${dep_match}" =~ "$dep_header" ]] && dependent_file+=" ${dep_match}"
            done
        done
        pdbg "$dependent_file"

        # 组装 obj 生成规则
        if [ "$types" = "so" ]; then
            target_objs+=" ${obj_name}.pic"
            [[ "$make_obj_names" =~ "${obj_name}.pic" ]] || {
                # append new obj_name
                make_obj_names+=" ${obj_name}.pic"
                echo >> $make_obj_file
                echo "${obj_name}.pic : ${path_name}$dependent_file" >> $make_obj_file
                printf "\t${CC} \$(COPTM) ${make_cflag} \$(CFLAG) -fPIC -c -o \$@ $path_name\n" >> $make_obj_file

            }
        elif [ "$types" = "ar" ]; then
            target_ars+=" ${obj_name}"
            [[ "$make_obj_names" =~ "${obj_name}" ]] || {
                # append new obj_name
                make_obj_names+=" ${obj_name}"
                echo >> $make_obj_file
                echo "${obj_name} : ${path_name}$dependent_file" >> $make_obj_file
                printf "\t${CC} \$(COPTM) ${make_cflag} \$(CFLAG) -c -o \$@ $path_name\n" >> $make_obj_file
            }
        elif  [ "$types" = "app" ]; then
            target_objs+=" ${obj_name}"
            [[ "$make_obj_names" =~ "${obj_name}" ]] || {
                # append new obj_name
                make_obj_names+=" ${obj_name}"
                echo >> $make_obj_file
                echo "${obj_name} : ${path_name}$dependent_file" >> $make_obj_file
                printf "\t${CC} \$(COPTM) ${make_cflag} \$(CFLAG) -c -o \$@ $path_name\n" >> $make_obj_file
            }
        else
            perr "impossible type"
        fi
	done
	
	
	
	# all: prepare <item0> <item1> ...
    if [ -n "$target_so" ]; then
        printf " $target_so" >> $makefiles
    fi

    if [ -n "$target_ar" ]; then
        printf " $target_ar" >> $makefiles
    fi

    if [ -n "$target_app" ]; then
        printf " $target_app" >> $makefiles
    fi
	
	#make all
	echo >> $makefiles
	echo "prepare:" >> $makefiles
	printf "\t@mkdir -p \$(BIN_DIR) \$(OBJ_DIR) ${make_subdir}\n" >> $makefiles
	#make clean
	echo >> $makefiles
	echo "clean:" >> $makefiles
	printf "\t@rm -fr \$(BIN_DIR)\n" >> $makefiles
	
	cat ${make_obj_file} >> $makefiles
	
	
	
	#reset
	make_subdir=""
	#remove all the *.mk files for next makefile
done
pinf "========================================================================"













